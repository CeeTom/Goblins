<!DOCTYPE html>
<head>
    <script type="text/javascript">
        "use strict";

        class Eventer {
            constructor() {
                this.listeners = {};
            }

            addEventListener(name, f) {
                if (!this.listeners[name])
                    this.listeners[name] = [];
                this.listeners[name].push(f);
            }

            removeEventListener(name, f) {
                if (this.listeners[name]) {
                    this.listeners[name] =
                        this.listeners[name].filter(v => v != f);
                }
            }

            dispatchEvent(name, o) {
                let toCall = this.listeners[name];
                if (toCall)
                    for (let idx in toCall)
                        toCall[idx](o);
                return true;
            }
        }

        function xhrPromise(method, endPoint, body) {
            return new Promise(function(res, rej) {
                let xhr = new XMLHttpRequest();
                xhr.onload = () => { res(xhr.responseText); }
                xhr.onerror = () => { rej(xhr.responseText); }
                xhr.open(method, endPoint);
                xhr.send(body);
            }); 
        }

        function loadJson(endPoint) {
            return xhrPromise("GET", endPoint, "").then(JSON.parse);
        }

        class AttackSelector {
            constructor(gameInfo, attacks) {
                let container = document.createElement("div");
                let attackContainer = document.createElement("div");
                let select = document.createElement("select");
                let emptyOption = document.createElement("option");
                emptyOption.innerHTML = "";
                emptyOption.value = -1;
                let newOption = document.createElement("option");
                newOption.innerHTML = "[New Attack]";
                select.appendChild(emptyOption);
                select.appendChild(newOption);
                for (let i in attacks) {
                    let option = document.createElement("option");
                    option.innerHTML = attacks[i].Name;
                    option.value = i;
                    select.appendChild(option);
                }
                select.addEventListener('change', ev => {
                    if (ev.target.value == -1)
                        return;
                    let attack = attacks[ev.target.value];
                    if (!attack) {
                        let atkId = 0;
                        for (let idx in attacks)
                            if (attacks[idx].Id >= atkId)
                                atkId = attacks[idx].Id + 1;
                        attack = {
                            Id: atkId,
                            Name: "New attack",
                            StrengthCost: 0,
                            MagicCost: 0,
                            Damages: [],
                            SelfDamages: [],
                        };
                    }
                    let display = new AttackDisplay(gameInfo, attack);
                    display.addEventListener('save', attack => {
                        attacks[attack.Id] = attack;
                        if (ev.target.attack) {
                            ev.target.value = attack.Id;
                            ev.target.innerHTML = attack.Name;
                        } else {
                            let option = document.createElement("option");
                            option.innerHTML = attack.Name;
                            option.value = attack.Id;
                            select.appendChild(option);
                            option.selected = true;
                        }
                    });
                    attackContainer.innerHTML = "";
                    attackContainer.appendChild(display.element);
                });

                container.appendChild(select);
                container.appendChild(attackContainer);
                this.element = container;
            }
        }

        class AttackDisplay extends Eventer {
            constructor(gameInfo, attack) {
                super();
                let display = document.createElement("div");

                let id = document.createElement("span");
                id.innerHTML = attack.Id.toString();
                display.appendChild(id);

                let name = document.createElement("input");
                name.type = "text";
                name.value = attack.Name;
                display.appendChild(name);

                let strCost = new NumberInput(attack.StrengthCost);
                display.appendChild(
                    new Labeled("Str Cost: ", strCost).element);

                let magCost = new NumberInput(attack.MagicCost);
                display.appendChild(
                    new Labeled("Mag Cost: ", magCost).element);

                let dmgs = new DamageList(gameInfo, attack.Damages);
                display.appendChild(
                    new Labeled("Damages: ", dmgs).element);

                let selfDmgs = new DamageList(gameInfo, attack.SelfDamages);
                display.appendChild(
                    new Labeled("Self Damages: ", selfDmgs).element);

                let saveButton = document.createElement("button");
                saveButton.innerHTML = "Save";
                saveButton.addEventListener('click', () => {
                    let toSave = {
                        Id: attack.Id,
                        Name: name.value,
                        StrengthCost: strCost.asInt(),
                        MagicCost: magCost.asInt(),
                        Damages: dmgs.asDamages(),
                        SelfDamages: selfDmgs.asDamages(),
                    };
                    xhrPromise("POST", "saveAttack",
                        JSON.stringify(toSave)).then(() => {
                            this.dispatchEvent('save', toSave);
                        }, err => {
                            alert("couldn't save");
                            console.log(err);
                        });
                });
                display.appendChild(saveButton);

                this.element = display;
            }
        }

        class DamageLi extends Eventer {
            constructor(gameInfo, damage) {
                super();
                let li = document.createElement("li");
                let editor = new DamageEditor(gameInfo, damage);
                let deleteButton = document.createElement("button");
                deleteButton.innerHTML = "Remove Damage";
                deleteButton.addEventListener('click',
                    () => this.dispatchEvent('removed', editor));
                li.appendChild(editor.element);
                li.appendChild(deleteButton);

                this.editor = editor;
                this.element = li;
            }
        }

        class DamageList {
            addDamage(damage) {
                let li = new DamageLi(this.gameInfo, damage);
                this.currDamages.push(li);
                this.element.insertBefore(li.element, this.addLi);
                li.addEventListener('removed', () => {
                    this.currDamages =
                        this.currDamages.filter(item => item != li);
                    this.element.removeChild(li.element);
                });
            }

            asDamages() {
                return this.currDamages.map(v => v.editor.asDamage());
            }

            constructor(gameInfo, damages) {
                this.gameInfo = gameInfo;
                this.currDamages = [];
                this.element = document.createElement("ul");
                this.addLi = document.createElement("li");

                function newDamage() {
                    return {
                        Type: 1,
                        Amount: 0,
                        Pierce: 0,
                        Statuses: [],
                        ScalingFunc: 0,
                        ScalingStat: 2,
                        ScalingMulti: 0,
                        Variance: 0,
                    };
                }

                let addButton = document.createElement("button");
                addButton.innerHTML = "Add Damage";

                addButton.addEventListener("click",
                    () => this.addDamage(newDamage()));

                this.addLi.appendChild(addButton);
                this.element.appendChild(this.addLi);

                for (let i = 0; i < damages.length; i++)
                    this.addDamage(damages[i]);
            }
        }

        class DamageEditor {
            constructor(gameInfo, damage) {
                this.element = document.createElement("div");

                let amountDiv = document.createElement("div");

                this.type =
                    new IdNamePairSelector(gameInfo.damageTypes, damage.Type);
                amountDiv.appendChild(this.type.element);

                this.amount = new NumberInput(damage.Amount);
                amountDiv.appendChild(this.amount.element);

                this.element.appendChild(amountDiv);

                this.pierce = new NumberInput(damage.Pierce);
                this.element.appendChild(
                    new Labeled("Pierce: ", this.pierce).element);

                this.scalingStat =
                    new IdNamePairSelector(gameInfo.stats,
                        damage.ScalingStat);
                this.element.appendChild(
                    new Labeled("Scaling Stat: ", this.scalingStat).element);

                this.scalingFunc =
                    new IdNamePairSelector(gameInfo.scalingFuncs,
                        damage.ScalingFunc);
                this.element.appendChild(
                    new Labeled("Scaling Func: ", this.scalingFunc).element);

                this.scalingMulti = new NumberInput(damage.ScalingMulti);
                this.element.appendChild(
                    new Labeled("Scaling Multi: ", this.scalingMulti).element);

                this.variance = new NumberInput(damage.Variance);
                this.element.appendChild(
                    new Labeled("Variance: ", this.variance).element);

                this.statuses = new StatusList(gameInfo, damage.Statuses);
                this.element.append(this.statuses.element);
            }

            asDamage() {
                return {
                    Type: this.type.asId(),
                    Amount: this.amount.asInt(),
                    Pierce: this.pierce.asFloat(),
                    ScalingStat: this.scalingStat.asId(),
                    ScalingFunc: this.scalingFunc.asId(),
                    ScalingMulti: this.scalingMulti.asFloat(),
                    Variance: this.variance.asFloat(),
                    Statuses: this.statuses.asStatuses(),
                };
            }
        }

        class StatusLi extends Eventer {
            constructor(gameInfo, status) {
                super();
                let li = document.createElement("li");
                let editor = new StatusEditor(gameInfo, status);
                let deleteButton = document.createElement("button");
                deleteButton.innerHTML = "Remove";
                deleteButton.addEventListener('click',
                    () => this.dispatchEvent('removed', editor));
                li.appendChild(editor.element);
                li.appendChild(deleteButton);

                this.editor = editor;
                this.element = li;
            }
        }

        class StatusEditor {
            constructor(gameInfo, status) {
                this.element = document.createElement("div");
                this.element.style.display = "inline-block";
                this.statusType =
                    new IdNamePairSelector(gameInfo.statuses, status.Status);
                this.element.appendChild(this.statusType.element);

                this.statusProb = new NumberInput(status.Probability);
                this.element.appendChild(
                    new Labeled("Probability: ",
                        this.statusProb,
                        {display: "inline-block"}).element);
            }

            asStatus() {
                return {
                    Status: this.statusType.asId(),
                    Probability: this.statusProb.asFloat(),
                };
            }
        }

        class StatusList {
            addStatus(status) {
                let li = new StatusLi(this.gameInfo, status);
                this.currStatuses.push(li);
                this.element.insertBefore(li.element, this.addLi);
                li.addEventListener('removed', () => {
                    this.currStatuses =
                        this.currStatuses.filter(item => item != li);
                    this.element.removeChild(li.element);
                });
            }

            asStatuses() {
                return this.currStatuses.map(v => v.editor.asStatus());
            }

            constructor(gameInfo, statuses) {
                this.gameInfo = gameInfo;
                this.currStatuses = [];
                this.element = document.createElement("ul");
                this.addLi = document.createElement("li");

                function newStatus() {
                    return {
                        Status: 0,
                        Probability: 0,
                    };
                }

                let addButton = document.createElement("button");
                addButton.innerHTML = "Add Status";

                addButton.addEventListener("click",
                    () => this.addStatus(newStatus()));

                this.addLi.appendChild(addButton);
                this.element.appendChild(this.addLi);

                for (let i = 0; i < statuses.length; i++)
                    this.addStatus(statuses[i]);
            }
        }

        class IdNamePairSelector {
            constructor(all, curr) {
                this.element = document.createElement("select");
                for (let id in all) {
                    let opt = document.createElement("option");
                    opt.value = id;
                    opt.innerHTML = all[id];
                    opt.selected = id == curr;
                    this.element.appendChild(opt);
                }
            }

            asId() {
                let options = this.element.getElementsByTagName("option");
                for (let idx in options)
                    if (options[idx].selected)
                        return options[idx].value|0;
            }
        }

        function applyStyle(elem, style) {
            if (style)
                for (let key in style)
                    elem.style[key] = style[key];
        }

        class NumberInput {
            constructor(value) {
                this.element = document.createElement("input");
                this.element.type = "number";
                this.element.step = "any";
                this.element.value = value;
            }

            asFloat() {
                return parseFloat(this.element.value);
            }

            asInt() {
                return this.element.value|0;
            }
        }

        class Labeled {
            constructor(label, comp, style, spanStyle) {
                this.element = document.createElement("div");
                let span = document.createElement("span");
                span.innerHTML = label;
                applyStyle(span, spanStyle);
                applyStyle(this.element, style);
                this.element.appendChild(span);
                this.element.appendChild(comp.element);
            }
        }

        function loadGameInfo() {
            function fillIdNamePairs(dict, pairs) {
                for (let idx = 0; idx < pairs.length; idx++)
                    dict[pairs[idx].Id] = pairs[idx].Name;
            }
            let gameInfo = {
                damageTypes: {},
                statuses: {},
                scalingFuncs: {},
                stats: {},
            };
            return loadJson("/damageTypes").then(function (types) {
                fillIdNamePairs(gameInfo.damageTypes, types);
                return loadJson("/statuses");
            }).then(function (statuses) {
                fillIdNamePairs(gameInfo.statuses, statuses);
                return loadJson("/scalingFuncs");
            }).then (function (scalingFuncs) {
                fillIdNamePairs(gameInfo.scalingFuncs, scalingFuncs);
                return loadJson("/stats");
            }).then(function (stats) {
                fillIdNamePairs(gameInfo.stats, stats);
                return gameInfo;
            });
        }

        function populateInterface() {
            loadGameInfo().then(function (gameInfo) {
                loadJson("/attacks").then(function (attacks) {
                    let attackList = new AttackSelector(gameInfo, attacks);
                    document.getElementById("editor")
                            .appendChild(attackList.element);
                }, function (err) {
                    console.log("couldn't load attacks", err);
                });
            }, function (err) {
                console.log("couldn't load gameinfo", err);
            });
        }

        window.addEventListener("load", populateInterface);
    </script>
</head>
<body>
    <h1>Goblins: Attack Editor</h2>
    <div id="editor"></div>
</body>
